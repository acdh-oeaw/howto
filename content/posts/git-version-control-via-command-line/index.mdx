---
title: Git version control via command line
lang: en
date: 2023-01-31T00:00:00.000Z
version: 1.0.0
authors:
  - probst-stefan
editors:
  - k√∂nigshofer-elisabeth
tags:
  - datenmanagement
abstract: This article introduces the main concepts in Git and basic Git
  commands that can be used from the command line. Understanding these commands
  will help you with using git in a code editor, the git desktop and other
  options, like github online
licence: ccby-4.0
toc: false
uuid: SBjyyMxmwXB0wOftI0qIk
---
In this resource you will learn

- essential git commands
- how to use git commands in the terminal
- how to get and install the software you need

## Version control and tracking changes

**Git**'s main purpose is to track changes in your projects, either for yourself or to keep a team updated. It works best when used with **plaintext file formats** such as **source code, XML/TEI documents** or **Markdown content**. While Git will happily store _images_, _audio files_, or `.doc` and `.pdf` documents. However, it was not designed to help you with changes in those kinds of documents and cannot its full diffing/merging capacities with them. 

**Git**

- solves the problem of keeping versions of text documents in sync among sometimes thousands of collaborators working on a software product.
- It helps integrate changes by multiple collaborators and also solve situations where two people edit the same part of a document.

Git can record which changes, to which documents, have been made when, and by whom. It allows to keep a detailed revision history of a project, because it can save snapshots of a project at specific points in time, thus being open to review any time in the future.

Version control allows to save versions of content, restore previous versions, and compare different versions. This is especially beneficial when working with multiple documents, and when working in teams of more than one (potentially working on the same document).

![Branches in git](images/branches.png "Git's version control works with branches.")

Git allows to create separate branches for changes to any document. For example, in the image above, the document is represented by the **main branch**. When a change should be created, a copy, the branch "feature A" is **pulled** from the main branch. Once the change is made, the feature branch is ready to transfer back into the main branch. Similarly, we can **fetch** a branch "feature B" and create another change. When changes have been **committed**, it can be **pushed** back into the main branch, too. Git version control features allow to trace those changes, consider them before they are **merged** into the main branch.

The paragraph above features **terminology** (in bold) that will become essential commands that enable us to work with Git.

### Official terminology: Working Area, Staging Area, Repository

This diagram is a great summary of how content moves in Git, between the ‚Äúworking area‚Äù, which is simply the files and folders in a project as they exist on your computer, the ‚Äústaging area‚Äù, which we can call a ‚Äúholding zone‚Äù, and the ‚Äúrepository‚Äù, which are the permanently recorded commit snapshots.

![A figure showing the different areas of the git workflow, working area, stating area, repository](images/stefan_git_terminology.png "Git workflow by Stefan Probst")

- **Working area:** This is where you manipulate your files. For example, you can make change to the text in an MDX document. The working area usually resides on your local machine.
- **Staging area:** This "holding zone" allows to **stage** changes in your documents, and **commit** those changes once you are comfortable, and **push** these changes to your repository.
- **Repository:** A repository is a central location where the data, files and documents are stored and managed. You can be the sole user of a repository or you can be a collaborator in a team.

Let‚Äôs look at how change tracking with Git works in practice, in a local project on your computer (no network connection required). We‚Äôll walk through how to work with Git in the terminal, because that is where Git was originally meant to be used, and because it helps to understand what is actually going on. This involves learning a handful of Git commands, and while that might seem intimidating at first, you‚Äôll see that it becomes second-nature with a bit of practice very quickly. 

However, if you prefer to work with Git via a **graphical user interface (GUI)**, take a look at the bonus section at the end of this introduction, which lists some popular editor or operating system integrations.

<SideNote type="note">
The commands you learn for working in a local project also apply for working collaboratively. Working in the terminal helps to understand what is going on behind the scenes.
</SideNote>

## Installing git

<SideNote type="tip" title="Don't be afraid of the command line interface (CLI)">
Many users, particularly Windows users, depend on using Graphical User Interfaces (GUI) in their daily lives and work schedules. GUIs have tabs, menus and windows that you can click on. GUIs are perceived as more user-friendly because they graphically represent the actions you take when you interact with the machine in front of you.

The command line interface (CLI) relies on text input. The user needs to know syntax and commands to use it. So instead of clicking on symbols, you type what you would like your machine to do. To open the command line, search for _terminal_ or _command promt_. When you open your CLI, it will look something like this:
```bash
C:\Users\user_name>path_to_your_directory
```
When using a Mac, you will see the **$** character instead of **>**. 

Here's an example for a basic command to use in your CLI: to navigate to a directory, type **cd** and the directory name. Now you can navigate down the directory hierarchy. To go back up, type **cd ..**
```bash
C:\Users\user_name>cd path_to_your_directory
C:\Users\user_name\path_to_your_directory> cd a_small_folder
C:\Users\user_name\path_to_your_directory\a_small_folder> cd ..
C:\Users\user_name\path_to_your directory> cd ..
C:\Users\user_name>
```
There are multifple tutorials available that help you to familiarise with the command line. 
</SideNote>

<SideNote type="info" title="Git for Windows, Mac, Linux">
### Windows

If you haven‚Äôt yet installed Git on your Windows computer, follow the instructions on https://git-scm.com/downloads, or https://gitforwindows.org/.

You should also provide some initial configuration.
The setup program runs as administrator as well as normal user. In general hit next and don‚Äôt change anything as most options are only relevant for advanced usage.

[One exception might be the editor](https://git-intro-wboe.acdh-dev.oeaw.ac.at/simple_windows_editors). But if you follow this howto, its use is not essential.

### Editors with git-support

To have an editor that supports us when working with git version control we suggest you use [Visual Studio Code.](https://code.visualstudio.com/) Just download the suggested stable build and install it.

See here why you might want to use VSCodium instead.

We suggest you let the setup program add an icon on your desktop. You can of course just search the start menu for VS(Codium) or (Visual Studio)Code.

Note that other specialized editors also support managing git repositories themselves. One notable example would be OxygenXML.

### add Mac and Linux
</SideNote>

## Initialise a Git project in your terminal

First, we need to tell Git that it should start to manage a project directory and keep an eye on changes to documents there. On a **Windows** PC, run the program **git shell** **(Git Bash)**, on **Mac** or **Linux** use the terminal of your choice. Navigate to the folder which contains the data you want to version (usually done by typing `cd {folder-name}`, e.g. _cd Documents_), and afterwards type:

```bash
git init
```

This will initially set up Git‚Äôs internal bookkeeping metadata, which is stored in a hidden .git folder. Git will respond with:

![initialise an empty Git repository on your local machine](images/git_initialise_empty_gitrepo.png "initialise an empty Git repository on your local machine")

Let‚Äôs also create some new content. In a real research project this would mean editing or adding an XML/TEI document or similar. To demonstrate the mechanics we‚Äôll keep it basic here and use the terminal to create a simple text file. When you want to  create a text file via the command line: The text in "", following _echo_, is the content of the text file which you specify with "filename.txt", txt being a text file extension

```bash
echo "This is my text document." > my-document.txt
```

### Check status

We can always check what Git knows about the state of our project with:

```bash
git status
```

Note that Git informs us that changes have been made to a file called `my-document.txt`, but that file is currently "untracked", which means it is not currently managed by Git's versioning. Git also tells us that in order to tell it to keep track of changes to that file, we should "use `git add` to track". Generally, if you find yourself in situations where you're unsure how to proceed, `git status` will most of the time show helpful hints. It's probably the Git command you'll be using most often.

![A picture of a code block. In the image you can see that a text file was created and that the status was checked. There are no commits yet, but some changes are already staged, others yet untracked.](images/add_file_status.png "In the image you can see that a text file was created and that the status was checked. There are no commits yet, but some changes are already staged, others yet untracked.")

### Mark content changes to be included in the version history

Let‚Äôs follow the advice and use `git add` to tell Git to keep an eye on changes to the newly created document `my-document.txt`:

```bash
git add my-document.txt
```

<SideNote type="info" title="Adding multiple files">
To add multiple files, it is possible to list them individually:
```bash
git add first-document.txt second-document.txt
```
Or, to include _all_ changes to the project:
```bash
git add -A
```
</SideNote>

Note that `git add` does not automatically **commit** the changes, but places them in the **staging area**.

### Bundle changes into meaningful chunks

Including content changes in Git‚Äôs version history involves a two-step process. First, we put changes in the ‚Äúholding zone‚Äù or **‚Äústaging area‚Äù**. We can continue adding related changes to other documents, or additional newly created documents. This allows **creating semantically meaningful units of changes**.

When all related changes have been added to the ‚Äúholding area‚Äù, we can save them together as a version history snapshot, with a message that briefly describes the changes so it is easy to find them later when viewing the version history.

These units are called **‚Äúcommits‚Äù**, and **‚Äúcommitting‚Äù** means permanently recording a snapshot of contents at a specific point in time, with a message describing the change:

```bash
git commit -m "Add test document"
```

<SideNote type="info" title="Commit messages">

Commit messages are usually written in imperative language. For example it is customary to say ‚ÄúChange document title‚Äù, not ‚ÄúChanged document title‚Äù. Nevertheless, it‚Äôs perfectly fine to agree on different project-specific conventions, just try to be consistent.

When in a hurry, it‚Äôs tempting to write non-descriptive commit messages like ‚ÄúAdded changes‚Äù. Try to come up with something that describes the change, you‚Äôll thank yourself later!
</SideNote>

Every project snapshot we commit to history should include a semantically meaningful set of changes, and this may involve edits to different documents. `git add` allows to granularly choose which changes, to which files should be part of the next snapshot, while `git commit` will label that set of changes, and actually save a new snapshot.

## History log, snapshots, revert, reverse

### View history of changes

Getting into the habit of assigning descriptive commit messages is especially helpful when viewing the history of changes. Git will print a changelog with:

```bash
git log --oneline
```

Note that we have one entry in our version history, and that Git has assigned the commit message we have provided, as well as an internal identifier to that entry. That identifier consists of 40 alphanumeric characters, but usually the first few characters are enough to uniquely address a commit in a project.

### View individual snapshot

Git will display the exact changes which were made in a commit snapshot with:

```bash
git show 7f733ac
```

That last bit is the unique identifier which is assigned to every commit in Git's version history. We've seen above how we can figure out these ids from inspecting the changelog displayed with `git log`. Note that when you have followed the steps in this introduction on your own computer, the unique identifier you see will be different from the one above. This is because identifiers are calculated from filename and content, author, commit message, and commit date.

### Compare two snapshots

It is also possible to show changes between two specific commit snapshots. Let's first add another change, so there are actually two separate entries in our commit history (again, how creating and editing a document on the terminal works is unimportant here, but the two-step process of creating a snapshot with `git add` and `git commit` should already be familiar):

```bash
echo "This is another document." > another-document.txt # creates a new document
sed -i s/text/test/ my-document.txt # changes "text" to "test" in `my-document.txt`
git add -A
git commit -m "Add new document and change initial document"
```

To list the difference between two commit snapshots we'll first find out their respective unique identifiers, and then tell Git to compare those:

```bash
git log --oneline
git diff 7f733ac ab9b27f
```

<SideNote type="info" title="Diffing not-yet-committed work">

To compare working directory to staging area:

```bash
git diff
```

To compare staging are to repository, i.e. last commit to next commit:

```bash
git diff --staged
```

</SideNote>

The format in which the changes are displayed can be a bit hard to read in the terminal, especially for larger changesets, so it's best to view them in a real text editor.

### Time travel

Alternatively, Git allows to "time travel" to a specific point in a project's history. You can inspect how each document looked like at that point in time, without losing any subsequent changes:

```bash
git checkout 7f733ac
```

Once you're done looking around, don't forget to return to the present! The easiest way is with:

```bash
git checkout main
```

The `main` identifier is just a shortcut way to refer to the default timeline (it's actually the default _branch_ of the timeline, because there can be multiple parallel timelines ü§Ø, we'll have a look at these branches in the second part of this introduction).

### Undo changes

Finally, Git also allows to undo changes. Even though Git forces us to be very intentional about which changes end up in the changelog (we needed to go through the two-step `git add` and `git commit` process after all), sometimes you'll still want to discard some of them.

There are three possible ways to do this.

```bash
git revert ab9b27f
```

Reverting a commit will keep that snapshot in the version history, and create a _new_ snapshot with the changes removed. This is useful when you want to keep a record of the initial changes, and the fact that they have been reverted.

```bash
git reset 7f733ac
```

Reseting history allows to "rewind the clock" to a specific point im time (addressed via unique identifier), without losing the changes that have been made to documents in subsequent changes. It's mostly useful as a way to "rewrite" history.

```bash
git reset --hard 7f733ac
```

The most brute-force way to undo changes is with a "hard reset". Be aware that this will not only "rewind the clock" to a specific commit, but nuke any changes that have been make in the project since that point in time. Those changes will be lost.

Lastly, if you only want to quickly change the _message_ of the last commit, for example because you made a typo, you can:

```bash
git commit --amend
```

## Links

### Cheatsheets

Git commands Github: https://education.github.com/git-cheat-sheet-education.pdf 

Git commands Gitlab: https://about.gitlab.com/images/press/git-cheat-sheet.pdf